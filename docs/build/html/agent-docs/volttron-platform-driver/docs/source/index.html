<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Platform Driver Framework &mdash; VOLTTRON DNP3 Outstation Agent 0.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            VOLTTRON DNP3 Outstation Agent
          </a>
              <div class="version">
                0.1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Platform Driver Framework</a><ul>
<li><a class="reference internal" href="#driver-conventions">Driver Conventions</a></li>
<li><a class="reference internal" href="#agent-driver-communication-patterns">Agent-Driver Communication Patterns</a><ul>
<li><a class="reference internal" href="#typical-single-platform-behavior">Typical Single Platform Behavior</a><ul>
<li><a class="reference internal" href="#lines-of-communication">Lines of Communication</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-case-drivers">Special Case Drivers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#installing-the-fake-driver">Installing the Fake Driver</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">VOLTTRON DNP3 Outstation Agent</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Platform Driver Framework</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/agent-docs/volttron-platform-driver/docs/source/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="platform-driver-framework">
<span id="driver-framework"></span><h1>Platform Driver Framework<a class="headerlink" href="#platform-driver-framework" title="Permalink to this headline"></a></h1>
<p>VOLTTRON drivers act as an interface between agents on the platform and a device.  While running on the platform,
drivers are special purpose agents which instead of being run as a separate process, are run as a greenlet in the
Platform Driver process.</p>
<p>Driver instances are created by the Platform Driver when a new driver configuration is added to the configuration store.
Drivers use the following topic pattern <cite>devices/&lt;campus&gt;/&lt;building&gt;/&lt;device id&gt;</cite>.  When a configuration file is added
to the Platform Driver’s store using this pattern, the Platform Driver creates a Driver Agent.  The Driver agent is then
instantiated with an instance of the Interface class corresponding to the <cite>driver_type</cite> parameter in the configuration
file.  The Interface class is responsible for implementing the communication paradigms of a device or protocol.  Once
configured, the Platform Driver periodically polls the Driver Agent for data which is collected from the interface class.
Additionally, points can be requested ad-hoc via the Platform Driver’s JSON-RPC method “get_point”. Points may be set
by using JSON-RPC with the Actuator agent to set up a schedule and calling the “set_point” method.</p>
<section id="driver-conventions">
<h2>Driver Conventions<a class="headerlink" href="#driver-conventions" title="Permalink to this headline"></a></h2>
<ul class="simple">
<li><p>Drivers are polled by the Platform Driver agent and values can be set using the <cite>Actuator Agent</cite>.</p></li>
<li><p>Drivers should have a 1-to-1 relationship with a device.</p></li>
<li><p>Driver modules should be written in Python files in the <cite>services/core/PlatformDriverAgent/platform_driver/interfaces</cite> directory in the VOLTTRON repository.  The platform driver will search for a Python file in this directory matching the name provided by the <cite>driver_type</cite> value from the driver configuration when creating the Driver agent.</p></li>
<li><p>Driver code consists of an Interface class (exactly named), supported in most cases by one or more Register classes.</p></li>
</ul>
</section>
<section id="agent-driver-communication-patterns">
<span id="driver-communication"></span><h2>Agent-Driver Communication Patterns<a class="headerlink" href="#agent-driver-communication-patterns" title="Permalink to this headline"></a></h2>
<p>The VOLTTRON message bus has been developed to allow agents on the platform to interact with each other, as well as with
ICS (Industrial Control Systems) and IOT (Internet of Things) devices via the VOLTTRON driver framework. Agents and
drivers have the ability to publish data to the message bus and to subscribe to message bus topics to read in data as it
is published. Additionally, agents may implement JSONRPC calls and expose JSONRPC endpoints to communicate more directly
with other agents. The following diagram demonstrates typical platform communication patterns for a single platform
deployment.</p>
<section id="typical-single-platform-behavior">
<h3>Typical Single Platform Behavior<a class="headerlink" href="#typical-single-platform-behavior" title="Permalink to this headline"></a></h3>
<p>The diagram features several entities that comprise the platform and its connected components:</p>
<ul class="simple">
<li><p>The VOLTTRON message bus - The message bus is the means of transmission of information in VOLTTRON. The VOLTTRON
message bus is built around existing message bus software; currently VOLTTRON supports RabbitMQ and ZeroMQ. The
VOLTTRON integration includes Pub/Sub and JSON RPC interfaces for agent and driver communication.</p></li>
<li><p>VOLTTRON Platform Agents and Subsystems - These agents and subsystems are installed on the platform to manage the
platform. They provide many user facing functions, aid in communication, and manage other agents and drivers.</p></li>
<li><p>User’s Agents - These agents are either agents included in the core repository but installed by a user or built by an end-user’s
agent modules. They may perform a huge variety of user specified tasks, including data collection, device control,
simulation, etc.</p></li>
<li><p>Platform Driver Agent - This agent facilitates communication with drivers. Agents should not
communicate directly with drivers. The platform driver implements several features for communicating with drivers to ensure
smooth operation and consistent driver behavior.</p></li>
<li><p>Actuator agent - This agent provides scheduling capability for controlling drivers. The
Platform Driver does not include protections for race conditions, etc. It is always recommended to use the Actuator
agent to set values on a device.</p></li>
<li><p>Device Driver - Drivers are special purpose agents which provide an interface between the platform driver and devices
such as Modbus and BACnet devices. Drivers implement a specific set of features for protecting device communication and
ensure uniform behaviors across different devices.</p></li>
<li><p>Device - Devices may be low level physical computers for controlling various systems such as PLCs (Programmable Logic
Controller), devices which communicate on the local network (such as a Smart T.V.), or devices which are accessed via
a remote web API (other smart devices).</p></li>
</ul>
<section id="lines-of-communication">
<h4>Lines of Communication<a class="headerlink" href="#lines-of-communication" title="Permalink to this headline"></a></h4>
<p>Connectivity of the platform follows the following paradigm:</p>
<ul class="simple">
<li><p>Platform agents (including the Platform Driver and Actuator), subsystems, and user agents communicate with the message
bus via a publish/subscribe system.</p></li>
<li><p>Agents can communicate “directly” to each other via JSONRPC (RPC). A JSONRPC call uses the VOLTTRON message bus router
to “direct” messages to an intended recipient. RPC calls from an agent specify a function for the recipient to
perform including input parameters; the response to the sender should contain the value output by the specified
function.</p></li>
<li><p>The Platform Driver will periodically poll device drivers. This functionality is intentionally not user-facing. The
Platform Driver iterates over the configured drivers and calls their respective “scrape_all” methods. This will trigger
the drivers to collect point values.</p></li>
<li><p>The Driver will communicate with its configured end devices to collect data points which it then returns to the
driver. The driver then publishes the point data to the bus under the <cite>&lt;campus&gt;/&lt;building&gt;/&lt;device id&gt;/all</cite> topic.</p></li>
<li><p>To get an individual device point, the user agent should send an RPC call to the Platform Driver for “get_point”,
providing the point’s corresponding topic. After the Platform Driver processes the request, communication happens very
similarly to polling, but rather than an “all” publish, the data is returned via the Platform Driver to the user agent.</p></li>
<li><p>To set a point on a device, it is recommended to use an Actuator Agent. The user agent sends an RPC request to the
Actuator to schedule time for the agent to control the device. During that scheduled time the user agent may send it
a set point request. If the schedule has been created, the actuator will then forward that request to the Platform
Driver, at which point the communication happens similarly to a “get_point” request.</p></li>
</ul>
<p>The general paradigm for the device-driver relationship as specified by the VOLTTRON driver framework is a 1-to-1
relationship. Each end device should be interacted with via a single device driver configured on one platform. To
distribute device data, the DataPuller and forwarder agents can be used at the platform level. Multiple platforms are
not intended to collect data or share control of a single device.</p>
<p>The below diagram demonstrates driver communication on the platform in a typical case.</p>
<img alt="../../../../_images/driver_flow.png" src="../../../../_images/driver_flow.png" />
<ol class="arabic">
<li><p>Platform agents and agents developed and/or installed by users communicate with the platform via pub/sub or JSON-RPC.
Agents share data for a number of reasons including querying historians for data to use in control algorithms,
fetching data from remote web APIs and monitoring.</p></li>
<li><p>A user agent which wants to request data ad-hoc sends a JSON-RPC request to the Platform Driver to <cite>get_point</cite>, asking
the driver to fetch the most up-to-date point data for the point topic provided.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>For periodic <cite>scrape_all</cite> data publishes, step 2 is not required.  The Platform Driver is configured to
automatically collect all point data for a device on a regular interval and publish the data to the bus.</p>
</div>
</div></blockquote>
</li>
<li><p>A user agent sends a request to the actuator to establish a schedule for sending device control signals, and during
the scheduled time sends a <cite>set_point</cite> request to the Actuator.  Given that the control signal arrives during the
scheduled period, the Actuator forwards the request to the Platform Driver.  If the control signal arrives outside the
scheduled period or without an existing schedule, a LockError exception will be thrown.</p></li>
<li><p>The Platform Driver issues a <cite>get_point</cite>/<cite>set_point</cite> call to the Driver corresponding to the request it was sent.</p></li>
<li><p>The device driver uses the interface class it is configured for to send a data request or control signal to the
device (i.e. the BACnet driver issues a <cite>readProperty</cite> request to the device).</p></li>
<li><p>The device returns a response indicating the current state.</p></li>
<li><p>The the response is forwarded to the requesting device.  In the case of a <cite>scrape_all</cite>, the device data is published
to the message bus.</p></li>
</ol>
</section>
</section>
<section id="special-case-drivers">
<h3>Special Case Drivers<a class="headerlink" href="#special-case-drivers" title="Permalink to this headline"></a></h3>
<p>Some drivers require a different communication paradigm. One common alternative is shown in the diagram below:</p>
<img alt="../../../../_images/proxy_driver_flow.png" src="../../../../_images/proxy_driver_flow.png" />
<p>This example describes an alternative pattern wherein BACnet drivers communicate via a BACnet proxy agent to communicate
with end devices. This behavior is derived from the networking requirements of the BACnet specification. BACnet
communication in the network layer requires that only one path exist between BACnet devices on a network.
In this case, the BACnet proxy acts as a virtual BACnet device, and device drivers forward their requests to this agent
which then implements the BACnet communication (whereas the typical pattern would have devices communicate directly with
the corresponding device). There are many other situations which may require this paradigm to be adopted (such as
working with remote APIs with request limits), and it is up to the party implementing the driver to determine if this
pattern or another pattern may be the most appropriate implementation pattern for their respective use case.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Other requirements for driver communication patterns may exist, but on an individual basis.  Please refer to the
documentation for the driver of interest for more about any atypical pattern that must be adhered to.</p>
</div>
</section>
</section>
<section id="installing-the-fake-driver">
<h2>Installing the Fake Driver<a class="headerlink" href="#installing-the-fake-driver" title="Permalink to this headline"></a></h2>
<p>The Fake Driver is included as a way to quickly see data published to the message bus in a format that mimics what a
real driver would produce.  This is a simple implementation of the VOLTTRON driver framework.</p>
<p>See <span class="xref std std-ref">instructions for installing the fake driver</span></p>
<p>To view data being published from the fake driver on the message bus, one can
<span class="xref std std-ref">install the Listener Agent</span> and read the VOLTTRON log file:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">cd</span><span class="w"> </span>&lt;root<span class="w"> </span>volttron<span class="w"> </span>directory&gt;
tail<span class="w"> </span>-f<span class="w"> </span>volttron.log
</pre></div>
</div>
<div class="toctree-wrapper compound">
</div>
<p>#   &lt;agent-docs/volttron-lib-chargepoint-driver/docs/source/index&gt;
#   &lt;agent-docs/volttron-lib-ecobee-web-driver/docs/source/index&gt;
#   &lt;agent-docs/volttron-lib-ieee-2030_5-driver/docs/source/index&gt;
#   &lt;agent-docs/volttron-lib-obix/docs/source/index&gt;
#   &lt;agent-docs/volttron-lib-the-energy-detective-driver/docs/source/index&gt;</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Pacific Northwest National Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>